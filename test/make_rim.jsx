var x = 100;var y = 100;var w = 10;var h = 10;var r = 50;var d = app.documents.add();var oval = d.pages.item(0).ovals.add({    geometricBounds:[y,x,y + r,x + r]    });oval.fillColor = d.swatches.item(5);var totalBoxes = 10;var arclength = 0;    var x1 = (x+ r/2)-w/2 ;    var y1 = (y +r/2)-w/2;    var x2 = x1 + w;    var y2 = y1 + w;      for (var i = 0; i < totalBoxes; i++) {          arclength += w/2;    var theta = (arclength / r);         var trnsMat =  app.transformationMatrices.add({horizontalTranslation:r * Math.cos(theta),                verticalTranslation:r * Math.sin(theta)});        var radians = (theta + (Math.PI/2) );             // turn radians to degrees        var degrees = radians * (180/Math.PI);            var rotMat = app.transformationMatrices.add();    rotMat = rotMat.rotateMatrix(degrees *-1);    var o  = oval.parent.ovals.add({geometricBounds:[y1,x1,y2,x2]});    o.transform(CoordinateSpaces.PARENT_COORDINATES, AnchorPoint.centerAnchor, trnsMat);        o.transform(CoordinateSpaces.PARENT_COORDINATES, AnchorPoint.centerAnchor, rotMat);            arclength += w/2;    var u = 2 * Math.PI * r;      if(arclength > u - w ){      r = r + w*2;      arclength = 0;            // if it gets to small stop the loop      if(r < w*2){        r = w;        break;      } // end of height check    } // end of arclength check      }/*make_circles (oval,d.swatches.item(3),50);function make_circles(oval,color,len){        var diam = (oval.geometricBounds[3] - oval.geometricBounds[1]);        var r = diam;    var pt = (oval.geometricBounds[3] - oval.geometricBounds[1])/10;    var arclength = 0;    var w = pt;    for(var i = 0; i < len; i++){            var x1 = (oval.geometricBounds[1] + (oval.geometricBounds[3] - oval.geometricBounds[1])/2) - w/2;    var y1 = (oval.geometricBounds[0] + (oval.geometricBounds[2] - oval.geometricBounds[0])/2)- w/2;    var x2 = x1 + w;    var y2 = y1 + w;    var o  = oval.parent.ovals.add({geometricBounds:[y1,x1,y2,x2]});    o.strokeColor = oval.parent.parent.swatches.item(0);    o.fillColor = color;            arclength += w/2;    var theta = Math.PI + arclength / r;   // Polar to Cartesian conversion allows us to find the point along the curve.     var trnsMat =  app.transformationMatrices.add({horizontalTranslation:r * Math.cos(theta),        verticalTranslation:r * Math.sin(theta)});	o.transform(CoordinateSpaces.pasteboardCoordinates, AnchorPoint.centerAnchor, trnsMat);        // Rotate the box (rotation is offset by 90 degrees)            // calc the rotation of the single image.        // this is in radians        var rot = (theta + (Math.PI/2));             // turn radians to degrees        var degrees = rot * (180/Math.PI);                var rotMat = app.transformationMatrices.add();rotMat = rotMat.rotateMatrix(degrees *-1);o.transform(CoordinateSpaces.PASTEBOARD_COORDINATES, AnchorPoint.centerAnchor, rotMat);       // Move  again        arclength += w;        var u = 2 * Math.PI * r;      if(arclength > u - w ){      r = r + pt*2;      arclength = 0;            // if it gets to small stop the loop      if(r < pt*2){        r = pt;        break;      } // end of height check    } // end of arclength check        }        }        */